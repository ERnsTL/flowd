use serde::Deserialize;
use std::collections::HashSet;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Deserialize)]
struct BuildConfig {
    components: ComponentsSection,
}

#[derive(Deserialize)]
struct ComponentsSection {
    entry: Vec<ComponentEntry>,
}

#[derive(Deserialize)]
struct ComponentEntry {
    name: String,
    #[serde(rename = "crate")]
    crate_name: String,
    #[serde(rename = "struct")]
    struct_name: String,
    log_ignore: Option<Vec<String>>,
}

fn main() {
    // set up
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let build_toml_path = Path::new(&manifest_dir).join("flowd.build.toml");
    println!("cargo:rerun-if-changed={}", build_toml_path.display());
    println!("cargo:rerun-if-changed={}", Path::new(&manifest_dir).join("build.rs").display());

    // load and validate build configuration
    let build_toml = fs::read_to_string(&build_toml_path)
        .unwrap_or_else(|err| panic!("failed to read {}: {err}", build_toml_path.display()));
    let config: BuildConfig = toml::from_str(&build_toml)
        .unwrap_or_else(|err| panic!("failed to parse flowd.build.toml: {err}"));

    if config.components.entry.is_empty() {
        panic!("flowd.build.toml has no component entries");
    }

    let dependency_names = load_dependency_names(Path::new(&manifest_dir));

    let mut seen_names: HashSet<String> = HashSet::new();
    let mut log_filters: Vec<String> = Vec::new();

    for entry in &config.components.entry {
        if entry.name.trim().is_empty() {
            panic!("component entry has empty name");
        }
        if entry.crate_name.trim().is_empty() {
            panic!("component '{}' has empty crate name", entry.name);
        }
        if entry.struct_name.trim().is_empty() {
            panic!("component '{}' has empty struct name", entry.name);
        }
        if !seen_names.insert(entry.name.clone()) {
            panic!("duplicate component name '{}'", entry.name);
        }

        // check if it is present
        validate_crate_name(Path::new(&manifest_dir), &dependency_names, &entry.crate_name);

        // push log filter, if set
        if let Some(filters) = &entry.log_ignore {
            for filter in filters {
                if !log_filters.contains(filter) {
                    log_filters.push(filter.clone());
                }
            }
        }
    }

    // initialize generated code string
    let mut generated = String::new();
    generated.push_str("// @generated by build.rs; do not edit.\n\n");

    // use block
    for entry in &config.components.entry {
        generated.push_str(&format!("use {}::{};\n", entry.crate_name, entry.struct_name));
    }
    generated.push_str("\n");

    // component library
    generated.push_str("pub(crate) fn build_component_library() -> Arc<RwLock<ComponentLibrary>> {\n");
    generated.push_str("    Arc::new(RwLock::new(ComponentLibrary::new(vec![\n");
    for entry in &config.components.entry {
        generated.push_str(&format!("        {}::get_metadata(),\n", entry.struct_name));
    }
    generated.push_str("    ])))\n");
    generated.push_str("}\n\n");

    // component factory function
    generated.push_str("pub(crate) fn instantiate_and_run_component(\n");
    generated.push_str("    name: &str,\n");
    generated.push_str("    inports: ProcessInports,\n");
    generated.push_str("    outports: ProcessOutports,\n");
    generated.push_str("    signalsource: ProcessSignalSource,\n");
    generated.push_str("    watchdog_signalsink: ProcessSignalSink,\n");
    generated.push_str("    graph_inout: Arc<Mutex<GraphInportOutportHolder>>,\n");
    generated.push_str(") -> bool {\n");
    generated.push_str("    match name {\n");
    for entry in &config.components.entry {
        generated.push_str(&format!(
            "        \"{}\" => {{ {}::new(inports, outports, signalsource, watchdog_signalsink, graph_inout).run(); true }},\n",
            escape_rust_string(&entry.name),
            entry.struct_name
        ));
    }
    generated.push_str("        _ => {\n");
    generated.push_str("            let _ = (inports, outports, signalsource, watchdog_signalsink, graph_inout);\n");
    generated.push_str("            false\n");
    generated.push_str("        }\n");
    generated.push_str("    }\n");
    generated.push_str("}\n");

    // component log filters function
    generated.push_str("pub fn register_component_log_filters(logger: &mut simplelog::ConfigBuilder) {\n");
    for filter in &log_filters {
        generated.push_str(&format!(
            "    logger.add_filter_ignore_str(\"{}\");\n",
            escape_rust_string(filter)
        ));
    }
    generated.push_str("}\n\n");

    // write generated code to file
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("build_generated.rs");
    fs::write(&out_path, generated)
        .unwrap_or_else(|err| panic!("failed to write {}: {err}", out_path.display()));
}

fn load_dependency_names(manifest_dir: &Path) -> HashSet<String> {
    let cargo_toml_path = manifest_dir.join("Cargo.toml");
    let cargo_toml = fs::read_to_string(&cargo_toml_path)
        .unwrap_or_else(|err| panic!("failed to read {}: {err}", cargo_toml_path.display()));
    let cargo_value: toml::Value = cargo_toml
        .parse()
        .unwrap_or_else(|err| panic!("failed to parse Cargo.toml: {err}"));

    let mut names = HashSet::new();
    if let Some(deps) = cargo_value.get("dependencies").and_then(|v| v.as_table()) {
        for name in deps.keys() {
            names.insert(name.to_string());
        }
    }
    names
}

//TODO change to support components in separate crates (TO-BE) instead of modules (AS-IS), e.g. by checking for a Cargo.toml in the crate path and looking for a lib.rs or src/lib.rs file there, and also supporting nested modules in the components directory, e.g. components/ssh/mod.rs or components/ssh.rs for components::ssh
fn validate_crate_name(manifest_dir: &Path, dependencies: &HashSet<String>, crate_name: &str) {
    if crate_name.starts_with("components::") {
        let module = crate_name.trim_start_matches("components::");
        if module.is_empty() || module.contains("::") {
            panic!("invalid components module path '{}'", crate_name);
        }
        let components_dir = manifest_dir.join("src/components");
        let file_path = components_dir.join(format!("{module}.rs"));
        let dir_path = components_dir.join(module).join("mod.rs");
        if !file_path.exists() && !dir_path.exists() {
            panic!("components module '{}' not found in src/components", module);
        }
        return;
    }

    if crate_name.contains("::") {
        panic!("crate name '{}' is not a valid crate path", crate_name);
    }

    if !dependencies.contains(crate_name) {
        panic!("crate '{}' not found in Cargo.toml dependencies", crate_name);
    }
}

fn escape_rust_string(value: &str) -> String {
    value.replace('\\', "\\\\").replace('\"', "\\\"")
}
